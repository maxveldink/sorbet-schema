# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorbet-result` gem.
# Please instead update this file by running `bin/tapioca gem sorbet-result`.


# source://sorbet-result//lib/minitest/result_assertions.rb#6
module Minitest
  class << self
    # source://minitest/5.24.1/lib/minitest.rb#323
    def __run(reporter, options); end

    # source://minitest/5.24.1/lib/minitest.rb#97
    def after_run(&block); end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def allow_fork; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def allow_fork=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#69
    def autorun; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def backtrace_filter; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def backtrace_filter=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#18
    def cattr_accessor(name); end

    # source://minitest/5.24.1/lib/minitest.rb#1208
    def clock_time; end

    # source://minitest/5.24.1/lib/minitest.rb#303
    def empty_run!(options); end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def extensions; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def extensions=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#336
    def filter_backtrace(bt); end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def info_signal; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def info_signal=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#125
    def init_plugins(options); end

    # source://minitest/5.24.1/lib/minitest.rb#109
    def load_plugins; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def parallel_executor; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def parallel_executor=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#143
    def process_args(args = T.unsafe(nil)); end

    # source://minitest/5.24.1/lib/minitest.rb#104
    def register_plugin(name_or_mod); end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def reporter; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def reporter=(_arg0); end

    # source://minitest/5.24.1/lib/minitest.rb#269
    def run(args = T.unsafe(nil)); end

    # source://minitest/5.24.1/lib/minitest.rb#1199
    def run_one_method(klass, method_name); end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def seed; end

    # source://minitest/5.24.1/lib/minitest.rb#19
    def seed=(_arg0); end
  end
end

# source://sorbet-result//lib/minitest/result_assertions.rb#7
module Minitest::Assertions
  # source://minitest/5.24.1/lib/minitest/assertions.rb#188
  def _synchronize; end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#201
  def _where; end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#178
  def assert(test, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#195
  def assert_empty(obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#221
  def assert_equal(exp, act, msg = T.unsafe(nil)); end

  # Fails unless exp is equal to error
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#24
  def assert_error(exp, result); end

  # Fails unless Result is a Failure
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#14
  def assert_failure(result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#242
  def assert_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#254
  def assert_in_epsilon(exp, act, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#261
  def assert_includes(collection, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#272
  def assert_instance_of(cls, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#283
  def assert_kind_of(cls, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#293
  def assert_match(matcher, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/mock.rb#250
  def assert_mock(mock); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#305
  def assert_nil(obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#315
  def assert_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#333
  def assert_output(stdout = T.unsafe(nil), stderr = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#357
  def assert_path_exists(path, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#376
  def assert_pattern; end

  # Fails unless exp is equal to payload
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#19
  def assert_payload(exp, result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#397
  def assert_predicate(o1, op, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#424
  def assert_raises(*exp); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#456
  def assert_respond_to(obj, meth, msg = T.unsafe(nil), include_all: T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#466
  def assert_same(exp, act, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#479
  def assert_send(send_ary, m = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#493
  def assert_silent; end

  # Fails unless Result is a Success
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#9
  def assert_success(result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#502
  def assert_throws(sym, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#543
  def capture_io; end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#576
  def capture_subprocess_io; end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#59
  def diff(exp, act); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#608
  def exception_details(e, msg); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#624
  def fail_after(y, m, d, msg); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#631
  def flunk(msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#639
  def message(msg = T.unsafe(nil), ending = T.unsafe(nil), &default); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#129
  def mu_pp(obj); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#152
  def mu_pp_for_diff(obj); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#650
  def pass(_msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#657
  def refute(test, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#665
  def refute_empty(obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#676
  def refute_equal(exp, act, msg = T.unsafe(nil)); end

  # Fails if exp is equal to error
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#44
  def refute_error(exp, result); end

  # Fails if Result is a Failure
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#34
  def refute_failure(result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#688
  def refute_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#700
  def refute_in_epsilon(a, b, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#707
  def refute_includes(collection, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#718
  def refute_instance_of(cls, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#728
  def refute_kind_of(cls, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#736
  def refute_match(matcher, obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#746
  def refute_nil(obj, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#781
  def refute_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#790
  def refute_path_exists(path, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#763
  def refute_pattern; end

  # Fails if exp is equal to payload
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#39
  def refute_payload(exp, result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#804
  def refute_predicate(o1, op, msg = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#813
  def refute_respond_to(obj, meth, msg = T.unsafe(nil), include_all: T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#822
  def refute_same(exp, act, msg = T.unsafe(nil)); end

  # Fails if Result is a Success
  #
  # source://sorbet-result//lib/minitest/result_assertions.rb#29
  def refute_success(result); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#835
  def skip(msg = T.unsafe(nil), _ignored = T.unsafe(nil)); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#847
  def skip_until(y, m, d, msg); end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#856
  def skipped?; end

  # source://minitest/5.24.1/lib/minitest/assertions.rb#104
  def things_to_diff(exp, act); end

  class << self
    # source://minitest/5.24.1/lib/minitest/assertions.rb#29
    def diff; end

    # source://minitest/5.24.1/lib/minitest/assertions.rb#47
    def diff=(o); end
  end
end

# source://sorbet-result//lib/typed/no_error_on_success_error.rb#4
module Typed; end

# source://sorbet-result//lib/typed/result.rb#138
class Typed::Failure < ::Typed::Result
  extend T::Generic

  Payload = type_member { { fixed: T.noreturn } }
  Error = type_member

  # source://sorbet-result//lib/typed/result.rb#163
  sig { params(error: Error).void }
  def initialize(error); end

  # source://sorbet-result//lib/typed/result.rb#189
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), Error])
  end
  def and_then(&_block); end

  # source://sorbet-result//lib/typed/result.rb#146
  sig { override.returns(Error) }
  def error; end

  # source://sorbet-result//lib/typed/result.rb#174
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/result.rb#198
  sig { override.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @raise [NoPayloadOnFailureError]
  #
  # source://sorbet-result//lib/typed/result.rb#179
  sig { override.returns(T.noreturn) }
  def payload; end

  # source://sorbet-result//lib/typed/result.rb#209
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # source://sorbet-result//lib/typed/result.rb#169
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/result.rb#158
    sig { returns(Typed::Failure[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/result.rb#153
    sig { type_parameters(:T).params(error: T.type_parameter(:T)).returns(Typed::Failure[T.type_parameter(:T)]) }
    def new(error); end
  end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_error_on_success_error.rb#6
class Typed::NoErrorOnSuccessError < ::StandardError
  # source://sorbet-result//lib/typed/no_error_on_success_error.rb#10
  sig { void }
  def initialize; end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#6
class Typed::NoPayloadOnFailureError < ::StandardError
  # source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#10
  sig { void }
  def initialize; end
end

# A monad representing either a success or a failure. Contains payload and error information as well.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://sorbet-result//lib/typed/result.rb#9
class Typed::Result
  extend T::Generic

  abstract!
  sealed!

  Payload = type_member(:out)
  Error = type_member(:out)

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#42
  sig do
    abstract
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(T.any(Typed::Result[T.type_parameter(:U), Error], Typed::Result[T.type_parameter(:U), T.type_parameter(:T)]))
  end
  def and_then(&_block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#33
  sig { abstract.returns(Error) }
  def error; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#25
  sig { abstract.returns(T::Boolean) }
  def failure?; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#50
  sig { abstract.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#29
  sig { abstract.returns(Payload) }
  def payload; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#59
  sig do
    abstract
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#21
  sig { abstract.returns(T::Boolean) }
  def success?; end
end

# source://sorbet-result//lib/typed/result.rb#63
class Typed::Success < ::Typed::Result
  extend T::Generic

  Payload = type_member
  Error = type_member { { fixed: T.noreturn } }

  # source://sorbet-result//lib/typed/result.rb#88
  sig { params(payload: Payload).void }
  def initialize(payload); end

  # source://sorbet-result//lib/typed/result.rb#114
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
  end
  def and_then(&block); end

  # @raise [NoErrorOnSuccessError]
  #
  # source://sorbet-result//lib/typed/result.rb#104
  sig { override.returns(T.noreturn) }
  def error; end

  # source://sorbet-result//lib/typed/result.rb#99
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/result.rb#123
  sig { override.params(_block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&_block); end

  # source://sorbet-result//lib/typed/result.rb#71
  sig { override.returns(Payload) }
  def payload; end

  # source://sorbet-result//lib/typed/result.rb#133
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        _value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(_value); end

  # source://sorbet-result//lib/typed/result.rb#94
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/result.rb#83
    sig { returns(Typed::Success[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/result.rb#78
    sig { type_parameters(:T).params(payload: T.type_parameter(:T)).returns(Typed::Success[T.type_parameter(:T)]) }
    def new(payload); end
  end
end
